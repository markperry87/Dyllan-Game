<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dylan's Extreme Hobby Balancer v3.1</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background-color: #1a1a1a;
            display: flex;
            justify-content: center;
            align-items: center;
            height: 100vh;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: white;
            flex-direction: column;
            overflow: hidden;
            user-select: none;
        }
        canvas {
            box-shadow: 0 0 50px rgba(0,0,0,0.8);
            border-radius: 12px;
            max-width: 100%;
            cursor: pointer;
        }
        #ui-layer {
            position: absolute;
            pointer-events: none;
            width: 800px;
            height: 400px;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
        }
        .hud-top {
            display: flex;
            justify-content: space-between;
            font-size: 24px;
            font-weight: bold;
            text-shadow: 2px 2px 0 #000;
        }
        .hearts { color: #ff4757; }
        .score { color: #ffd700; }
        #start-screen {
            position: absolute;
            background: rgba(0,0,0,0.85);
            width: 800px;
            height: 400px;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            border-radius: 12px;
            z-index: 10;
            text-align: center;
        }
        h1 { margin: 0 0 10px 0; font-size: 40px; color: #fff; text-shadow: 0 0 10px #00d2ff; }
        p { font-size: 18px; color: #ccc; margin: 5px; }
        .death-msg { color: #ff4757; font-size: 22px; margin: 15px 0; font-weight: bold; }
        .blink { animation: blinker 1s linear infinite; color: #ffd700; font-weight: bold; margin-top: 20px; cursor: pointer;}
        @keyframes blinker { 50% { opacity: 0; } }
    </style>
</head>
<body>

    <div id="ui-layer">
        <div class="hud-top">
            <div class="score">Tea: <span id="scoreDisplay">0</span></div>
            <div class="hearts" id="livesDisplay">‚ù§‚ù§‚ù§</div>
        </div>
    </div>

    <div id="start-screen">
        <h1>‚õ∞Ô∏è HOBBY BALANCER 3.1</h1>
        <p>Avoid üõãÔ∏è DIY Couches & üìÑ Paperwork</p>
        <p>Collect üçµ Tea for Energy</p>
        <p class="blink">[ CLICK TO START ]</p>
    </div>

    <canvas id="gameCanvas" width="800" height="400"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const startScreen = document.getElementById('start-screen');
    const scoreDisplay = document.getElementById('scoreDisplay');
    const livesDisplay = document.getElementById('livesDisplay');

    // --- Audio System ---
    const Audio = {
        ctx: null,
        init: function() {
            if (!this.ctx) {
                this.ctx = new (window.AudioContext || window.webkitAudioContext)();
            }
        },
        playTone: function(freq, type, duration, vol = 0.1) {
            if (!this.ctx) return;
            const osc = this.ctx.createOscillator();
            const gain = this.ctx.createGain();
            osc.type = type;
            osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
            gain.gain.setValueAtTime(vol, this.ctx.currentTime);
            gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
            osc.connect(gain);
            gain.connect(this.ctx.destination);
            osc.start();
            osc.stop(this.ctx.currentTime + duration);
        },
        jump: function() { this.playTone(300, 'sine', 0.1); },
        jump2: function() { this.playTone(500, 'sine', 0.1); },
        collect: function() { this.playTone(1200, 'triangle', 0.1, 0.05); },
        hit: function() { 
            this.playTone(100, 'sawtooth', 0.3, 0.1); 
            this.playTone(80, 'square', 0.3, 0.1);
        },
        gameOver: function() {
            this.playTone(150, 'sawtooth', 0.8);
            setTimeout(() => this.playTone(100, 'sawtooth', 0.8), 200);
        }
    };

    // --- Game State ---
    let gameState = 'START'; 
    let gameSpeed = 5;
    let score = 0;
    let frame = 0;
    let shakeIntensity = 0;
    let animationId = null; // Used to kill the loop properly
    
    // --- Environment ---
    const anchorY = 320; 
    let lineSag = 0;

    // --- Player ---
    const dylan = {
        x: 100, y: 280, width: 40, height: 50,
        dy: 0, jumpPower: -12, gravity: 0.65,
        grounded: true, jumpCount: 0, maxJumps: 2,
        rotation: 0, emoji: "üßó",
        lives: 3, invulnerable: 0
    };

    // --- Objects ---
    let obstacles = [];
    let teas = [];
    let particles = [];
    let stars = [];

    // --- Star Gen ---
    for(let i=0; i<50; i++) stars.push({x:Math.random()*800, y:Math.random()*300, size:Math.random()*2});

    // --- Inputs ---
    function handleAction() {
        if (gameState === 'START' || gameState === 'GAMEOVER') {
            startGame();
            return;
        }
        
        if (dylan.grounded) {
            dylan.dy = dylan.jumpPower;
            dylan.grounded = false;
            dylan.jumpCount = 1;
            createDust(dylan.x + 20, dylan.y + 50);
            Audio.jump();
        } else if (dylan.jumpCount < dylan.maxJumps) {
            dylan.dy = dylan.jumpPower * 0.9;
            dylan.jumpCount++;
            dylan.rotation -= 6.28; 
            createDust(dylan.x + 20, dylan.y + 50, "#fff");
            Audio.jump2();
        }
    }

    window.addEventListener('keydown', (e) => { if (e.code === 'Space') handleAction(); });
    // Use mousedown on the screen div to ensure clicks work
    startScreen.addEventListener('mousedown', handleAction);
    canvas.addEventListener('mousedown', handleAction);
    window.addEventListener('touchstart', (e) => { e.preventDefault(); handleAction(); }, {passive: false});

    function startGame() {
        Audio.init();
        if (Audio.ctx && Audio.ctx.state === 'suspended') Audio.ctx.resume();
        
        // CRITICAL FIX: Stop any existing loop before starting a new one
        if (animationId) cancelAnimationFrame(animationId);

        gameState = 'PLAYING';
        startScreen.style.display = 'none';
        
        // Reset Variables
        score = 0;
        dylan.lives = 3;
        gameSpeed = 5; // Reset speed to base level
        obstacles = [];
        teas = [];
        dylan.y = 200;
        dylan.dy = 0;
        frame = 0;
        updateUI();
        
        loop();
    }

    function takeDamage(sourceName) {
        if (dylan.invulnerable > 0) return;
        
        dylan.lives--;
        dylan.invulnerable = 60; 
        shakeIntensity = 20; 
        Audio.hit();
        updateUI();

        if (dylan.lives <= 0) {
            gameOver(sourceName);
        }
    }

    function gameOver(cause) {
        gameState = 'GAMEOVER';
        Audio.gameOver();
        startScreen.innerHTML = `
            <h1>GAME OVER</h1>
            <p class="death-msg">Defeated by: ${cause}</p>
            <p>Final Score: ${score}</p>
            <p class="blink">[ CLICK TO TRY AGAIN ]</p>
        `;
        startScreen.style.display = 'flex';
    }

    function updateUI() {
        scoreDisplay.innerText = score;
        livesDisplay.innerText = "‚ù§".repeat(dylan.lives);
    }

    function createDust(x, y, color = "#ddd") {
        for (let i = 0; i < 5; i++) {
            particles.push({
                x: x, y: y,
                vx: (Math.random() - 0.5) * 4,
                vy: Math.random() * -3,
                life: 1.0, color: color, type: 'dust'
            });
        }
    }

    function getSkyColor() {
        // Cycle 0=Noon, 0.5=Sunset, 1.0=Night
        const cycle = (Math.sin(frame * 0.001) + 1) / 2;
        
        if (cycle < 0.5) {
            return ["#87CEEB", "#E0F6FF"]; // Day
        } else if (cycle < 0.8) {
            return ["#FF7F50", "#483D8B"]; // Sunset
        } else {
            return ["#0f0c29", "#302b63"]; // Night
        }
    }

    function update() {
        if (gameState !== 'PLAYING') return;

        frame++;
        gameSpeed += 0.001; // Slow acceleration

        // --- Screen Shake Decay ---
        if (shakeIntensity > 0) shakeIntensity *= 0.9;
        if (shakeIntensity < 0.5) shakeIntensity = 0;

        // --- Invulnerability ---
        if (dylan.invulnerable > 0) dylan.invulnerable--;

        // --- Physics ---
        dylan.dy += dylan.gravity;
        dylan.y += dylan.dy;

        // Rotation smoothing
        if (dylan.grounded) dylan.rotation = dylan.rotation * 0.8;
        else if (dylan.jumpCount < 2) dylan.rotation += 0.05;

        // --- Slackline Physics ---
        if (dylan.y + dylan.height - 10 >= anchorY && dylan.dy >= 0) {
            dylan.y = anchorY - dylan.height + 10;
            dylan.dy = 0;
            dylan.grounded = true;
            dylan.jumpCount = 0;
            lineSag = 15;
            if(Math.abs(dylan.dy) > 1) createDust(dylan.x+20, anchorY);
        } else {
            lineSag *= 0.8;
        }

        // --- Spawner ---
        if (frame % 100 === 0) {
            const rand = Math.random();
            if (rand > 0.6) {
                obstacles.push({ x: canvas.width, y: anchorY - 30, width: 50, height: 40, emoji: "üõãÔ∏è", name: "A Half-Built Couch" });
            } else if (rand > 0.3) {
                obstacles.push({ x: canvas.width, y: anchorY - 90, width: 40, height: 40, emoji: "üìÑ", name: "Bureaucracy", type: 'air' });
            }
        }
        
        if (frame % 60 === 0 && Math.random() > 0.4) {
            teas.push({ x: canvas.width, y: 150 + Math.random() * 100, width: 30, height: 30, wobble: 0, emoji: "üçµ" });
        }

        // --- Collision ---
        // Obstacles
        for (let i = obstacles.length - 1; i >= 0; i--) {
            let obs = obstacles[i];
            obs.x -= gameSpeed;
            if (obs.type === 'air') obs.x -= 2; 

            // Hitbox
            if (
                dylan.x + 10 < obs.x + obs.width - 10 &&
                dylan.x + dylan.width - 10 > obs.x + 10 &&
                dylan.y + 10 < obs.y + obs.height - 5 &&
                dylan.y + dylan.height - 5 > obs.y + 5
            ) {
                takeDamage(obs.name);
                obstacles.splice(i, 1);
            } else if (obs.x + obs.width < 0) {
                obstacles.splice(i, 1);
            }
        }

        // Tea
        for (let i = teas.length - 1; i >= 0; i--) {
            let tea = teas[i];
            tea.x -= gameSpeed;
            tea.wobble += 0.1;
            tea.y += Math.sin(tea.wobble) * 0.5;

            if (
                dylan.x < tea.x + tea.width &&
                dylan.x + dylan.width > tea.x &&
                dylan.y < tea.y + tea.height &&
                dylan.y + dylan.height > tea.y
            ) {
                score += 10;
                updateUI();
                createDust(tea.x, tea.y, "#FFD700");
                Audio.collect();
                teas.splice(i, 1);
            } else if (tea.x + tea.width < 0) {
                teas.splice(i, 1);
            }
        }

        // Particles
        for (let i = particles.length - 1; i >= 0; i--) {
            let p = particles[i];
            p.x += p.vx;
            p.y += p.vy;
            p.life -= 0.05;
            if (p.life <= 0) particles.splice(i, 1);
        }
    }

    function draw() {
        ctx.save();
        if (shakeIntensity > 0) {
            const dx = (Math.random() - 0.5) * shakeIntensity;
            const dy = (Math.random() - 0.5) * shakeIntensity;
            ctx.translate(dx, dy);
        }

        const sky = getSkyColor();
        const grd = ctx.createLinearGradient(0, 0, 0, canvas.height);
        grd.addColorStop(0, sky[0]);
        grd.addColorStop(1, sky[1]);
        ctx.fillStyle = grd;
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        if (sky[0] === "#0f0c29") {
            ctx.fillStyle = "#FFF";
            stars.forEach(s => {
                ctx.beginPath();
                ctx.arc(s.x, s.y, s.size, 0, Math.PI*2);
                ctx.fill();
            });
        }

        ctx.fillStyle = (sky[0] === "#0f0c29") ? "#1a1a2e" : "#708090";
        ctx.beginPath();
        ctx.moveTo(0, 400); ctx.lineTo(200, 150); ctx.lineTo(500, 400); ctx.fill();
        ctx.fillStyle = (sky[0] === "#0f0c29") ? "#16213e" : "#5d6d7e";
        ctx.beginPath();
        ctx.moveTo(300, 400); ctx.lineTo(600, 100); ctx.lineTo(900, 400); ctx.fill();

        ctx.strokeStyle = "#333";
        ctx.lineWidth = 4;
        ctx.beginPath();
        ctx.moveTo(0, anchorY);
        if (dylan.grounded) {
            ctx.lineTo(dylan.x + 20, anchorY + lineSag); 
            ctx.lineTo(canvas.width, anchorY);
        } else {
            ctx.lineTo(canvas.width, anchorY);
        }
        ctx.stroke();

        particles.forEach(p => {
            ctx.globalAlpha = p.life;
            ctx.fillStyle = p.color;
            ctx.beginPath();
            ctx.arc(p.x, p.y, 4, 0, Math.PI*2);
            ctx.fill();
        });
        ctx.globalAlpha = 1.0;

        ctx.font = "40px Arial";
        obstacles.forEach(obs => ctx.fillText(obs.emoji, obs.x, obs.y + 35));

        ctx.font = "30px Arial";
        teas.forEach(tea => ctx.fillText(tea.emoji, tea.x, tea.y + 25));

        if (dylan.invulnerable % 4 < 2) { 
            ctx.save();
            ctx.translate(dylan.x + dylan.width/2, dylan.y + dylan.height/2);
            ctx.rotate(dylan.rotation);
            ctx.font = "50px Arial";
            ctx.textAlign = "center";
            ctx.textBaseline = "middle";
            ctx.fillText(dylan.emoji, 0, 0);
            ctx.restore();
        }

        ctx.restore();
    }

    function loop() {
        if (gameState === 'PLAYING') {
            update();
            draw();
            animationId = requestAnimationFrame(loop);
        }
    }
    
    // Initial Render
    draw();

</script>
</body>
</html>
